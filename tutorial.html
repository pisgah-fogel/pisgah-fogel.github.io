<!DOCTYPE html><meta charset="UTF-8"><html><head><link rel="stylesheet" href="styles.css"></head><body id="main"><div id="content"><h1> Qemu and Linux kernel hacking</h1><p>We are going to compile Qemu (emulator) from source so we can modify it in an other tutorial.
<br />We will add a custom system call in the linux, compile the linux kernel, and finally write program to call our syscall (ramfs are usually used to start the actual system but we are going to write our own minimalist system).
<br /></p><p>Objective: Get more familiar with the linux kernel environment/structure.
<br /></p><h2> Setting up Qemu</h2><ul><li>Download QEmu:</li></ul><pre><code>wget https://download.qemu.org/qemu-5.1.0.tar.xz
</code></pre><ul><li>Untar/Uncompress (keep the archive so you can revert your changes if needed):</li></ul><pre><code>tar xf ./qemu-5.1.0.tar.xz && cd
qemu-5.1.0
</code></pre><ul><li>Create a directory for your experimental Qemu: </li></ul><pre><code>mkdir ../qemu_bin
</code></pre><ul><li>Check for dependencies for your platform <a href="https://wiki.qemu.org/Hosts/Linux">wiki.qemu.org/Hosts/Linux</a> </li><li>If you are on debian you can use:</li></ul><pre><code>sudo apt-get install git
	   libglib2.0-dev libfdt-dev
	   libpixman-1-dev
	   zlib1g-dev
</code></pre><ul><li>Configure: </li></ul><pre><code>./configure --prefix=$PWD/../qemu_bin
</code></pre><ul><li>Make: </li></ul><pre><code>make
</code></pre><p>Note: you can have a look at the next section while this is running
<br /></p><ul><li>Install (in your test directory): </li></ul><pre><code>make install
</code></pre><h2> Getting a Linux image</h2><p>If you want to learn more about creating your own embedded linux: <a href="https://wiki.gentoo.org/wiki/Custom_Initramfs">wiki.gentoo.org/wiki/Custom_Initramfs</a> | <a href="https://tldp.org/HOWTO/Bootdisk-HOWTO/x88.html">tldp.org/HOWTO/Bootdisk-HOWTO/x88.html</a> | <a href="https://tldp.org/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html">tldp.org/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html</a> | <a href="https://www.linuxfromscratch.org/lfs/view/stable/
">www.linuxfromscratch.org/lfs/view/stable/
</a><br /></p><ul><li>Get linux source code</li><li>Start with a default linux kernel config:</li></ul><pre><code>make defconfig # Get default config

# Make sure you have the following settings in .config
CONFIG_EXT4_FS=y
CONFIG_IA32_EMULATION=y
CONFIG_VIRTIO_PCI=y (Virtualization -> PCI driver for virtio devices)
CONFIG_VIRTIO_BALLOON=y (Virtualization -> Virtio balloon driver)
CONFIG_VIRTIO_BLK=y (Device Drivers -> Block -> Virtio block driver)
CONFIG_VIRTIO_NET=y (Device Drivers -> Network device support -> Virtio network
driver)
CONFIG_VIRTIO=y
CONFIG_VIRTIO_RING=y

</code></pre><ul><li>You can edit your config with the nice ncurse interface: </li></ul><pre><code>make menuconfig
</code></pre><ul><li>Optional: Make an image to be used inside Qemu: (Will take a while)</li></ul><pre><code>make bzImage
</code></pre><ul><li>Optional: Create an initial system to run:</li></ul><pre><code>/sbin/mkinitramfs -o ramdisk.img
</code></pre><ul><li>Optional: Try your kernel:</li></ul><pre><code># To quit: Ctrl+a c q
./bin/qemu-system-x86_64 -drive driver=raw,file=./hd.img,if=virtio \
	-m 1024 \
	-kernel /data/projects/linux_staging/arch/x86/boot/bzImage \
	-initrd ramdisk.img \
	-no-reboot \
	-nographic -append "console=ttyS0"
</code></pre><ul><li>Optional: If you want to graphical interface:</li></ul><pre><code>cd your_path_to_qemu_bin/
# Create a virtual hard-drive
./bin/qemu-img create -f raw hd.img 8G
./bin/qemu-system-x86_64 -drive driver=raw,file=./hd.img,if=virtio \
	-m 1024 \
	-kernel /data/projects/linux_staging/arch/x86/boot/bzImage \
	-initrd ramdisk.img \
	-no-reboot

</code></pre><p>Install a vnc client (example for debian):
<br /></p><pre><code>sudo apt install tigervnc-viewer
</code></pre><p>Get the screen from your Qemu VM:
<br /></p><pre><code>vncviewer
127.0.0.1::5900
</code></pre><h2> Add a syscall in the linux kernel</h2><ul><li>arch/x86/entry/syscalls/syscall_64.tbl</li></ul><pre><code># After the last common entry
447	common	hello	sys_hello

</code></pre><ul><li>kernel/sys.c</li></ul><pre><code>struct __attribute__((__packed__)) filestat {
	unsigned long st_dev; /* ID of device containing file */
	unsigned long st_uid; /* user ID of owner */
	unsigned long st_gid; /* group ID of owner */
	unsigned long st_rdev; /* device ID (if special file) */
};

SYSCALL_DEFINE2(hello, const char*, path, struct filestat*, buf)
{
	char buffer[256];
	long copied = strncpy_from_user(buffer, path, sizeof(buffer));
	if (copied < 0 || copied == sizeof(buffer))
	return -EFAULT;
	printk(KERN_INFO "hello argument from the user: \"%s\"\n",
	buf->st_dev = 42; // Just a simple test
	return 0;
}

</code></pre><h2> Write a C program calling this syscall</h2><p>You can learn more about syscall by reading the
<br />manual: 
<br /></p><pre><code>man â€“S 2 intro
</code></pre><ul><li>test.c</li></ul><pre><code>#include <stdio.h>
#include <stdio.h>
#include <unistd.h>

struct __attribute__((__packed__)) filestat {
	unsigned long st_dev; /* ID of device containing file */
	unsigned long st_uid; /* user ID of owner */
	unsigned long st_gid; /* group ID of owner */
	unsigned long st_rdev; /* device ID (if special file) */
};

int main(int argc, char* argv[])
{
	printf("Testing syscall 447...\n");
	char array[] = "Hello, world!\n";
	struct filestat fs;
	fs.st_dev = 0;
	printf("st_dev before call %ld.\n", fs.st_dev);
	long res = syscall(447, array, &fs);
	printf("System call returned %ld.\n", res);
	printf("st_dev after call %ld.\n", fs.st_dev);
	sleep(999999999);
}

</code></pre><ul><li>Compile (Statically): </li></ul><pre><code>gcc -static test.c -o init
</code></pre><ul><li>Convert to RAM filesystem: </li></ul><pre><code>echo init | cpio -o -H newc | gzip > test.cpio.gz
</code></pre><ul><li>Run (Ctrl+a c q to quit):</li></ul><pre><code>./bin/qemu-system-x86_64 -drive driver=raw,file=./hd.img,if=virtio \
-m 1024 \
-kernel /data/projects/linux_staging/arch/x86/boot/bzImage \
-initrd ./test.cpio.gz \
-no-reboot \
-nographic -append "console=ttyS0"
</code></pre><h2> Write a syscall that does something</h2><p>By the time you read this I am very likely done with writing it, just ping me so I update it
<br /></p><h2> Add instruction in Qemu</h2><h2> Create performance monitoring linux kernel module</h2><h2> Create a page fault profiler linux kernel module</h2><h2> Write a multi-threading library</h2><h2> Write your own CPU simulator using Qemu</h2><h2> Add GCC support for your own CPU</h2><h2> Further reading</h2><p>Understanding the Linux Kernel, Third Edition by Daniel P. Bovet, Marco Cesati Ph.D
<br /></p></div></body></html>